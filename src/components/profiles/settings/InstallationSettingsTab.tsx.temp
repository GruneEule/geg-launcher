"use client";

import { useEffect, useRef, useState } from "react";
import { Icon } from "@iconify/react";
import type { ModLoader, Profile, ResolvedLoaderVersion } from "../../../types/profile";
import type { MinecraftVersion } from "../../../types/minecraft";
import { invoke } from "@tauri-apps/api/core";
import { StatusMessage } from "../../ui/StatusMessage";
import { useThemeStore } from "../../../store/useThemeStore";
import { SearchWithFilters } from "../../ui/SearchWithFilters";
import { Select } from "../../ui/Select";
import { Card } from "../../ui/Card";
import { Checkbox } from "../../ui/Checkbox";
import { gsap } from "gsap";
import { cn } from "../../../lib/utils";
import { Button } from "../../ui/buttons/Button";

import { toast } from "react-hot-toast";
import * as ProfileService from "../../../services/profile-service";

interface InstallationSettingsTabProps {
  profile: Profile;
  editedProfile: Profile;
  updateProfile: (updates: Partial<Profile>) => void;
  refreshTrigger?: number; // Increment this to trigger a refresh
}

type VersionType = "release" | "snapshot" | "old-beta" | "old-alpha";

export function InstallationSettingsTab({
  profile,
  editedProfile,
  updateProfile,
  refreshTrigger,
}: InstallationSettingsTabProps) {
  const [selectedVersionType, setSelectedVersionType] =
    useState<VersionType>("release");
  const [minecraftVersions, setMinecraftVersions] = useState<
    MinecraftVersion[]
  >([]);
  const [filteredVersions, setFilteredVersions] = useState<string[]>([]);
  const [isLoadingVersions, setIsLoadingVersions] = useState(true);
  const [loaderVersions, setLoaderVersions] = useState<string[]>([]);
  const [isLoadingLoaderVersions, setIsLoadingLoaderVersions] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [isRepairing, setIsRepairing] = useState(false);
  const [resolvedLoaderVersion, setResolvedLoaderVersion] = useState<ResolvedLoaderVersion | null>(null);
  const accentColor = useThemeStore((state) => state.accentColor);
  const isBackgroundAnimationEnabled = useThemeStore(
    (state) => state.isBackgroundAnimationEnabled,
  );
  const tabRef = useRef<HTMLDivElement>(null);
  const currentInstallRef = useRef<HTMLDivElement>(null);
  const versionsRef = useRef<HTMLDivElement>(null);
  const platformsRef = useRef<HTMLDivElement>(null);
  const loaderVersionRef = useRef<HTMLDivElement>(null);
  const scrollContainerRef = useRef<HTMLDivElement | null>(null);
  const [previousLoader, setPreviousLoader] = useState<string>(
    editedProfile.loader || "vanilla",
  );

  useEffect(() => {
    const findScrollContainer = () => {
      let element: HTMLDivElement | null = tabRef.current;
      while (element) {
        const overflowY = window.getComputedStyle(element).overflowY;
        if (overflowY === "auto" || overflowY === "scroll") {
          return element;
        }
        element = element.parentElement as HTMLDivElement | null;
      }
      return null;
    };

    if (tabRef.current) {
      scrollContainerRef.current = findScrollContainer();
    }
  }, []);

  useEffect(() => {
    const currentLoader = editedProfile.loader || "vanilla";

    if (previousLoader !== currentLoader) {
      if (
        currentLoader !== "vanilla" &&
        loaderVersionRef.current &&
        isBackgroundAnimationEnabled
      ) {
        scrollToLoaderVersion();
      }

      setPreviousLoader(currentLoader);
    }
  }, [editedProfile.loader, previousLoader, isBackgroundAnimationEnabled]);

  useEffect(() => {
    if (isBackgroundAnimationEnabled) {
      if (tabRef.current) {
        gsap.fromTo(
          tabRef.current,
          { opacity: 0 },
          { opacity: 1, duration: 0.4, ease: "power2.out" },
        );
      }

      const elements = [
        currentInstallRef.current,
        versionsRef.current,
        platformsRef.current,
      ].filter(Boolean);

      gsap.fromTo(
        elements,
        { opacity: 0, y: 20 },
        {
          opacity: 1,
          y: 0,
          duration: 0.4,
          stagger: 0.1,
          ease: "power2.out",
          delay: 0.2,
        },
      );
    }
  }, [isBackgroundAnimationEnabled]);

  useEffect(() => {
    async function fetchMinecraftVersions() {
      try {
        setIsLoadingVersions(true);
        setError(null);
        const result = await invoke<{ versions: MinecraftVersion[] }>(
          "get_minecraft_versions",
        );
        setMinecraftVersions(result.versions);
      } catch (err) {
        console.error("Failed to fetch Minecraft versions:", err);
        setError(
          `failed to fetch minecraft versions: ${err instanceof Error ? err.message : String(err)}`,
        );
      } finally {
        setIsLoadingVersions(false);
      }
    }

    fetchMinecraftVersions();
  }, []);

  useEffect(() => {
    if (minecraftVersions.length > 0) {
      const filtered = minecraftVersions
        .filter((version) => version.type === selectedVersionType)
        .filter((version) =>
          searchQuery
            ? version.id.toLowerCase().includes(searchQuery.toLowerCase())
            : true,
        )
        .map((version) => version.id);
      setFilteredVersions(filtered);
    }
  }, [minecraftVersions, selectedVersionType, searchQuery]);

  useEffect(() => {
    async function fetchLoaderVersions() {
      if (!editedProfile.game_version || editedProfile.loader === "vanilla") {
        setLoaderVersions([]);
        return;
      }

      try {
        setIsLoadingLoaderVersions(true);
        setError(null);
        let versions: string[] = [];

        switch (editedProfile.loader) {
          case "fabric":
            const fabricResult = await invoke<{ loader: { version: string } }[]>(
              "get_fabric_loader_versions",
              {
                minecraftVersion: editedProfile.game_version,
              },
            );
            versions = fabricResult.map((v) => v.loader.version);
            break;
          case "forge":
            versions = await invoke<string[]>("get_forge_versions", {
              minecraftVersion: editedProfile.game_version,
            });
            break;
          case "quilt":
            const quiltResult = await invoke<{ loader: { version: string } }[]>(
              "get_quilt_loader_versions",
              {
                minecraftVersion: editedProfile.game_version,
              },
            );
            versions = quiltResult.map((v) => v.loader.version);
            break;
          case "neoforge":
            versions = await invoke<string[]>("get_neoforge_versions", {
              minecraftVersion: editedProfile.game_version,
            });
            break;
        }

        setLoaderVersions(versions);
      } catch (err) {
        console.error(`Failed to fetch ${editedProfile.loader} versions:`, err);
        setError(
          `failed to fetch ${editedProfile.loader} versions: ${err instanceof Error ? err.message : String(err)}`,
        );
      } finally {
        setIsLoadingLoaderVersions(false);
      }
    }

    fetchLoaderVersions();
  }, [editedProfile.game_version, editedProfile.loader]);

  useEffect(() => {
    async function fetchResolvedLoaderVersion() {
      if (!editedProfile.game_version || editedProfile.loader === "vanilla") {
        setResolvedLoaderVersion(null);
        return;
      }

      try {
        const resolved = await invoke<ResolvedLoaderVersion>("resolve_loader_version", {
          profileId: editedProfile.id,
          minecraftVersion: editedProfile.game_version,
        });
        setResolvedLoaderVersion(resolved);
      } catch (err) {
        console.error("Failed to resolve loader version:", err);
        setResolvedLoaderVersion(null);
      }
    }

    fetchResolvedLoaderVersion();
  }, [editedProfile.id, editedProfile.game_version, editedProfile.loader, editedProfile.loader_version, editedProfile.settings.use_overwrite_loader_version, editedProfile.settings.overwrite_loader_version, editedProfile.selected_norisk_pack_id]);

  // Separate function that can be called externally
  const fetchResolvedLoaderVersion = async () => {
    if (!editedProfile.game_version || editedProfile.loader === "vanilla") {
      setResolvedLoaderVersion(null);
      return;
    }

    try {
      const resolved = await invoke<ResolvedLoaderVersion>("resolve_loader_version", {
        profileId: editedProfile.id,
        minecraftVersion: editedProfile.game_version,
      });
      setResolvedLoaderVersion(resolved);
    } catch (err) {
      console.error("Failed to resolve loader version:", err);
      setResolvedLoaderVersion(null);
    }
  };

  // Effect to refresh when parent signals a save occurred
  useEffect(() => {
    if (refreshTrigger) {
      fetchResolvedLoaderVersion();
    }
  }, [refreshTrigger]);

  function isModLoaderCompatible(
    loader: string,
    minecraftVersion: string,
  ): boolean {
    if (loader === "vanilla") return true;

    switch (loader) {
      case "fabric":
        return isVersionNewerOrEqual(minecraftVersion, "1.14");
      case "forge":
        return true;
      case "quilt":
        return isVersionNewerOrEqual(minecraftVersion, "1.14");
      case "neoforge":
        return isVersionNewerOrEqual(minecraftVersion, "1.20.1");
      default:
        return false;
    }
  }

  function isVersionNewerOrEqual(
    version: string,
    baseVersion: string,
  ): boolean {
    const parseVersion = (v: string) => {
      const parts = v.split(".");
      return {
        major: Number.parseInt(parts[0]) || 0,
        minor: Number.parseInt(parts[1]) || 0,
        patch: Number.parseInt(parts[2]) || 0,
      };
    };

    const v1 = parseVersion(version);
    const v2 = parseVersion(baseVersion);

    if (v1.major !== v2.major) return v1.major > v2.major;
    if (v1.minor !== v2.minor) return v1.minor > v2.minor;
    return v1.patch >= v2.patch;
  }

  const handleVersionTypeClick = (type: string) => {
    const versionType = type as VersionType;
    if (selectedVersionType !== versionType) {
      setSelectedVersionType(versionType);
      // Animation entfernt da wir keine Buttons mehr haben
    }
  };

  const handleGameVersionClick = (versionId: string) => {
    updateProfile({ game_version: versionId, loader_version: null });
    if (isBackgroundAnimationEnabled) {
      scrollToPlatforms();
    }
  };

  const handleLoaderClick = (loaderName: string) => {
    const newLoader = (
      editedProfile.loader === loaderName ? "vanilla" : loaderName
    ) as ModLoader;
    updateProfile({ loader: newLoader, loader_version: null });

    if (newLoader !== "vanilla" && isBackgroundAnimationEnabled) {
      scrollToLoaderVersion();
    }
  };

  const scrollToPlatforms = () => {
    if (!platformsRef.current || !scrollContainerRef.current) return;
    if (isBackgroundAnimationEnabled) {
      gsap.to(scrollContainerRef.current, {
        duration: 0.5,
        scrollTo: {
          y:
            platformsRef.current.offsetTop -
            scrollContainerRef.current.offsetTop -
            20,
          autoKill: true,
        },
        ease: "power2.out",
      });
      gsap.fromTo(
        platformsRef.current,
        { scale: 0.98, opacity: 0.5 },
        { scale: 1, opacity: 1, duration: 0.4, ease: "power2.out" },
      );
    }
  };

  const scrollToLoaderVersion = () => {
    if (!loaderVersionRef.current || !scrollContainerRef.current) return;
    if (isBackgroundAnimationEnabled) {
      gsap.to(scrollContainerRef.current, {
        duration: 0.5,
        scrollTo: {
          y:
            loaderVersionRef.current.offsetTop -
            scrollContainerRef.current.offsetTop -
            20,
          autoKill: true,
        },
        ease: "power2.out",
      });
      gsap.fromTo(
        loaderVersionRef.current,
        { scale: 0.98, opacity: 0.5 },
        { scale: 1, opacity: 1, duration: 0.4, ease: "power2.out" },
      );
    }
  };

  const handleRepair = async () => {
    try {
      setIsRepairing(true);
      setError(null);
      
      await ProfileService.repairProfile(profile.id);
      
      toast.success("Profile repair completed successfully!");
    } catch (err) {
      console.error("Failed to repair profile:", err);
      const errorMessage = err instanceof Error ? err.message : String(err);
      setError(`Failed to repair profile: ${errorMessage}`);
      toast.error(`Failed to repair profile: ${errorMessage}`);
    } finally {
      setIsRepairing(false);
    }
  };

  const getReasonText = (reason: string): string => {
    switch (reason) {
      case "norisk_pack":
        return "Forced by NoRisk Pack";
      case "user_overwrite":
        return "User Overwrite";
      case "profile_default":
        return "Profile Default";
      case "not_resolved":
        return "Not Resolved";
      default:
        return reason;
    }
  };

  return <div>Fixed</div>;
